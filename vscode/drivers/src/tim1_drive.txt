#include "tim1_driver.h"

void TIM1_TimeBaseInit(uint16_t TIM1_Prescaler,
                       TIM1_CounterMode_TypeDef TIM1_CounterMode,
                       uint16_t TIM1_Period,
                       uint8_t TIM1_RepetitionCounter)
{
    /* Set the Auto-reload value */
    TIM1_ARRH = (uint8_t)(TIM1_Period >> 8);
    TIM1_ARRL = (uint8_t)(TIM1_Period);

    /* Set the Prescaler value */
    TIM1_PSCRH = (uint8_t)(TIM1_Prescaler >> 8);
    TIM1_PSCRL = (uint8_t)(TIM1_Prescaler);

    /* Select the Counter Mode */
    TIM1_CR1 = (uint8_t)((TIM1_CR1 & (uint8_t)(~(TIM1_CR1_CMS | TIM1_CR1_DIR)))
                         | (uint8_t)(TIM1_CounterMode));

    /* Set the Repetition Counter value */
    TIM1_RCR = TIM1_RepetitionCounter;
}

/* ================= TIM1 Channel 4 ================= */

void TIM1_OC4Init(TIM1_OCMode_TypeDef TIM1_OCMode,
                  TIM1_OutputState_TypeDef TIM1_OutputState,
                  uint16_t TIM1_Pulse,
                  TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
                  TIM1_OCIdleState_TypeDef TIM1_OCIdleState)
{
    /* Disable the Channel 4 */
    TIM1_CCER2 &= (uint8_t)(~(TIM1_CCER2_CC4E | TIM1_CCER2_CC4P));

    /* Set Output State and Polarity */
    if (TIM1_OutputState)
        TIM1_CCER2 |= TIM1_CCER2_CC4E;

    if (TIM1_OCPolarity)
        TIM1_CCER2 |= TIM1_CCER2_CC4P;

    /* Set Output Compare Mode */
    TIM1_CCMR4 = (uint8_t)((TIM1_CCMR4 & (uint8_t)(~TIM1_CCMR_OCM))
                           | TIM1_OCMode);

    /* Set Output Idle State */
    if (TIM1_OCIdleState)
        TIM1_OISR |= TIM1_OISR_OIS4;
    else
        TIM1_OISR &= (uint8_t)(~TIM1_OISR_OIS4);

    /* Set Pulse value */
    TIM1_CCR4H = (uint8_t)(TIM1_Pulse >> 8);
    TIM1_CCR4L = (uint8_t)(TIM1_Pulse);
}

/* ================= Preload ================= */

void TIM1_OC4PreloadConfig(FunctionalState NewState)
{
    if (NewState)
        TIM1_CCMR4 |= TIM1_CCMR_OCxPE;
    else
        TIM1_CCMR4 &= (uint8_t)(~TIM1_CCMR_OCxPE);
}

void TIM1_ARRPreloadConfig(FunctionalState NewState)
{
    if (NewState)
        TIM1_CR1 |= TIM1_CR1_ARPE;
    else
        TIM1_CR1 &= (uint8_t)(~TIM1_CR1_ARPE);
}

/* ================= Control ================= */

void TIM1_Cmd(FunctionalState NewState)
{
    if (NewState)
        TIM1_CR1 |= TIM1_CR1_CEN;
    else
        TIM1_CR1 &= (uint8_t)(~TIM1_CR1_CEN);
}

void TIM1_CtrlPWMOutputs(FunctionalState NewState)
{
    if (NewState)
        TIM1_BKR |= TIM1_BKR_MOE;
    else
        TIM1_BKR &= (uint8_t)(~TIM1_BKR_MOE);
}

/* ================= Compare ================= */

void TIM1_SetCompare4(uint16_t Compare4)
{
    TIM1_CCR4H = (uint8_t)(Compare4 >> 8);
    TIM1_CCR4L = (uint8_t)(Compare4);
}

/* ================= Encoder ================= */

void TIM1_EncoderInterfaceConfig(TIM1_EncoderMode_TypeDef TIM1_EncoderMode,
                                 TIM1_ICPolarity_TypeDef TIM1_IC1Polarity,
                                 TIM1_ICPolarity_TypeDef TIM1_IC2Polarity)
{
    /* Set IC polarities */
    if (TIM1_IC1Polarity)
        TIM1_CCER1 |= TIM1_CCER1_CC1P;
    else
        TIM1_CCER1 &= (uint8_t)(~TIM1_CCER1_CC1P);

    if (TIM1_IC2Polarity)
        TIM1_CCER1 |= TIM1_CCER1_CC2P;
    else
        TIM1_CCER1 &= (uint8_t)(~TIM1_CCER1_CC2P);

    /* Set encoder mode in SMCR */
    TIM1_SMCR = (uint8_t)((TIM1_SMCR & 0xC0)
                          | (uint8_t)TIM1_EncoderMode);

    /* Select CC1 and CC2 as input */
    TIM1_CCMR1 = (uint8_t)((TIM1_CCMR1 & (uint8_t)(~TIM1_CCMR_CCxS)) | 0x01);
    TIM1_CCMR2 = (uint8_t)((TIM1_CCMR2 & (uint8_t)(~TIM1_CCMR_CCxS)) | 0x01);
}

/* ================= Counter ================= */

uint16_t TIM1_GetCounter(void)
{
    return ((uint16_t)TIM1_CNTRH << 8) | TIM1_CNTRL;
}

void TIM1_SetCounter(uint16_t Counter)
{
    TIM1_CNTRH = (uint8_t)(Counter >> 8);
    TIM1_CNTRL = (uint8_t)(Counter);
}

uint16_t TIM1_GetPrescaler(void)
{
    return ((uint16_t)TIM1_PSCRH << 8) | TIM1_PSCRL;
}